package export

import (
	"errors"
	"path"
	"strconv"

	"github.com/jung-kurt/gofpdf"
	"github.com/oklog/ulid/v2"
)

func _findFractionOfColumns(content [][]string) ([]float64, error) {
	if len(content) == 0 {
		return make([]float64, 0), errors.New("no content found")
	}

	columnCount := 0
	if len(content[0]) > 0 {
		columnCount = len(content[0])
	} else {
		return nil, errors.New("no columns in content")
	}

	maxSizes := make([]int, columnCount)

	for _, row := range content {
		if len(row) != columnCount {
			continue
		}

		for columnIndex, cell := range row {
			cellLength := len(cell)
			if cellLength > maxSizes[columnIndex] {
				maxSizes[columnIndex] = cellLength
			}
		}
	}

	defaultMaxSize := 40
	defaultMinSize := 10
	for i, maxSize := range maxSizes {
		if maxSize > defaultMaxSize {
			maxSizes[i] = defaultMaxSize
		} else if maxSize < defaultMinSize {
			maxSizes[i] = defaultMinSize
		}
	}

	totalSize := 0
	for _, s := range maxSizes {
		totalSize += s
	}

	if totalSize == 0 {
		percentages := make([]float64, columnCount)
		for i := range percentages {
			percentages[i] = 1.0 / float64(columnCount)
		}
		return percentages, nil
	}

	percentages := make([]float64, len(maxSizes))
	for i, s := range maxSizes {
		percentage := float64(s) / float64(totalSize)
		percentages[i] = percentage
	}
	return percentages, nil
}

// savePdfFile creates a PDF with a table, handling text wrapping for cells that overflow.
func savePdfFile(conf *Conf, tableData [][]string) (string, error) {
	filePath := path.Join(conf.FileBasePath, ulid.Make().String()+".pdf")
	pdf := gofpdf.New(conf.Pdf.Orientation, "mm", conf.Pdf.PageSize, "")

	// calculate page size
	pageWidth, pageHeight := pdf.GetPageSize()
	margin := 10.0
	footerHeight := 15.0 // Reserve space for the footer
	availableWidth := pageWidth - 2*margin

	// set footer
	pdf.SetFooterFunc(func() {
		pdf.SetY(-footerHeight)
		pdf.SetFont("Arial", "I", 5)
		pageStr := "Page " + strconv.Itoa(pdf.PageNo())
		footerText := "Document generated by Bitcomm Technologies Pvt. Ltd"
		pdf.CellFormat(0, 10, footerText+" - "+pageStr, "", 0, "C", false, 0, "")
		pdf.Ln(5)
		pdf.SetTextColor(120, 170, 250)
		pdf.CellFormat(0, 10, "bitcommtechnologies.com", "", 0, "C", false, 0, "https://bitcommtechnologies.com")
	})

	pdf.AddPage()

	// --- Document Title ---
	pdf.SetFont("Arial", "B", 12)
	pdf.CellFormat(0, 10, conf.Pdf.Title, "", 1, "C", false, 0, "")
	pdf.Ln(5)

	// --- Column Width Calculation ---
	headerAliases := conf.getAliases()
	if len(headerAliases) == 0 {
		return "", errors.New("no column headers defined in configuration")
	}

	contentForWidthCalc := append([][]string{headerAliases}, tableData...)
	spaceFraction, err := _findFractionOfColumns(contentForWidthCalc)
	if err != nil {
		// Fallback to equal widths if calculation fails
		colCount := len(headerAliases)
		spaceFraction = make([]float64, colCount)
		for i := range colCount {
			spaceFraction[i] = 1.0 / float64(colCount)
		}
	}

	colWidths := make([]float64, len(headerAliases))
	for i, fraction := range spaceFraction {
		colWidths[i] = availableWidth * fraction
	}

	// table header function
	drawTableHeader := func() {
		pdf.SetFont("Arial", "B", 7)
		pdf.SetFillColor(124, 171, 247)
		pdf.SetTextColor(0, 0, 0)

		headerLineHeight := 7.0

		// --- Calculate Header Height based on wrapping ---
		maxLines := 1
		for i, headerStr := range headerAliases {
			lines := pdf.SplitLines([]byte(headerStr), colWidths[i])
			if len(lines) > maxLines {
				maxLines = len(lines)
			}
		}
		headerHeight := float64(maxLines) * headerLineHeight

		startX, startY := pdf.GetX(), pdf.GetY()

		for i, headerStr := range headerAliases {
			pdf.Rect(startX, startY, colWidths[i], headerHeight, "FD")
			pdf.MultiCell(colWidths[i], headerLineHeight, headerStr, "", "C", false)
			startX += colWidths[i]
			pdf.SetXY(startX, startY)
		}
		pdf.Ln(headerHeight)
	}

	drawTableHeader()

	// table content function
	dataLineHeight := 6.0
	for _, row := range tableData {
		// Calculate Row Height and Handle Page Breaks
		maxLinesInRow := 1
		for i, cellStr := range row {
			if i >= len(colWidths) {
				break // Avoid panic on malformed rows
			}
			lines := pdf.SplitLines([]byte(cellStr), colWidths[i])
			if len(lines) > maxLinesInRow {
				maxLinesInRow = len(lines)
			}
		}
		dataRowHeight := float64(maxLinesInRow) * dataLineHeight

		// Check if the calculated row height fits on the current page.
		if pdf.GetY()+dataRowHeight > (pageHeight - margin - footerHeight) {
			pdf.AddPage()
			drawTableHeader()
		}

		// Set the font for data rows here to ensure it's correct after a page break.
		pdf.SetFont("Arial", "", 7)
		pdf.SetTextColor(0, 0, 0)

		// Draw the Data Row
		startX, startY := pdf.GetX(), pdf.GetY()
		for i, cellStr := range row {
			if i >= len(colWidths) {
				break
			}
			pdf.Rect(startX, startY, colWidths[i], dataRowHeight, "D")
			pdf.MultiCell(colWidths[i], dataLineHeight, cellStr, "", "C", false)
			startX += colWidths[i]
			pdf.SetXY(startX, startY)
		}
		pdf.Ln(dataRowHeight)
	}

	// --- Save the PDF File ---
	if err := pdf.OutputFileAndClose(filePath); err != nil {
		return "", err
	}
	return filePath, nil
}
